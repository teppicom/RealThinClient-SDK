You can find information on updating the RTC SDK components in the "Readme.txt" file.

**********************************************************
*                                                        *
* RealThinClient SDK v4.35 (2011.Q3) September 7th 2011. *
*                                                        *
**********************************************************

---------------------------------------------------------
* Changes in v4.35
---------------------------------------------------------

1) "rtcZLib" code standardized between MacOSX and iOS.
   Both platforms are now using the "libz.dylib" library.

---------------------------------------------------------
* Changes in v4.34
---------------------------------------------------------

1) Added automatic Compression/Decompression support for the iOS platform.
   Automatic compression for remote functions is now available for all platforms.

2) Enabled Compression on all "FishFacts" Demo Projects.

---------------------------------------------------------
* Changes in v4.33
---------------------------------------------------------

1) Added support for the ARM CPU, so the RTC SDK now also compiles for iOS devices.

---------------------------------------------------------
* Changes in v4.32
---------------------------------------------------------

1) Fixed BSD socket implementation for the iOS-Simulator (iPhone/iPad).

2) Added a simple FireMonkey iOS Project using the RTC SDK under "Demos\iOS".

   Before you can test this Project on the iOS-Simulator, you will need Delphi XE2 
   installed on Windows and your Mac OSX machine set up for iPhone/iPad development.
   Please follow instructions provided by Embarcadero to install both.

   Once you have your development environments set up, you will need to install the
   RTC SDK in Delphi and copy the complete "Lib" folder from the RTC SDK to Mac OSX,
   into a folder visible by the FPC compiler used by XCode. Since there are no naming 
   collisions between the RTC SDK and FireMonkey, the you could simply copy all files 
   from the RTC SDK's "Lib" folder (including subfolders) into the FireMonkey folder,
   which should (by default) be "Developer\Embarcadero\fmi" on the Mac OSX machine.

   Before you can open a Delphi Project inside XCode, you will need to create a XCode
   Project, which can be easily done by executing the "_makeXCodeProject.cmd" file,
   located in the "Demos\iOS" folder. To simplify debugging and development, you should
   share the complete "Demos\iOS" folder on Windows (where the Project files are located),
   so you can work on the files form Windows (Delphi XE2) and Mac (XCode).

   If you open the Project in Delphi, you will be able to run it under Windows, 
   because it will be compiled by Delphi into a 32bit Windows executable (for testing).
   
   To run the project inside the iOS-Simulator on Mac OSX, you will need to open the 
   XCode Project file generated by "makeXcodeProject.cmd", which can be found in the
   "Demos\iOS\xcode" folder ("xcode" directly below the Main Project folder).

   Once the Project is open in XCode, you can select the Simulator type (iPad or iPhone)
   and run the Project. FPC will be executed by XCode to compile the Project. 

   If you have installed everything correctly and the RTC SDK files ("Lib" folder) are
   accessible by the FPC compiler, the Project should compile and you should see the 
   Form (as designed in the Delphi IDE) inside the iOS-Simulator.

   Clicking on the "Call" button, the "Nothing yet" label will change to the Address
   and Port number you've entered on the Form and a remote function call will be
   sent to the Server. If the Server is not running or not accessible by the Client,
   the label will change to "Request Aborted". If the Server was running and the
   Client was able to connect and retrieve data, the label changes to "Received ** rows".

   Please note that RTC SDK support for iOS is currently in BETA and has only been 
   tested inside the iOS-Simulator. If you find any problems running iOS applications
   using the RTC SDK, please try creating a simple FireMonkey iOS HD Project which
   reproduces the issue and send it with your problem report to the RTC Support E-Mail.


---------------------------------------------------------
* Changes in v4.31
---------------------------------------------------------

1) "fmxFishFactsClient" Demo Project added to the "Demos\DB_Access" folder.

   This project implements the "FishFactsClient" as a FireMonkey Application,
   using the "TRtcMemDataSet" component for in-memory storage and utilizing
   the new LiveBindings functionality for linking DataSet Data to visual controls.

   This project can be compiled to run on Windows as well as MacOSX, but
   please note that RTC SDK support for Mac OSX is still in BETA, so that some 
   RTC SDK functionality may still be missing or working incorrectly on Mac OSX.

---------------------------------------------------------
* Changes in v4.30
---------------------------------------------------------

1) Functions "RtcDataSetFieldsToDelphi" and "RtcDataSetRowsToDelphi" added to the "rtcDB.pas" unit.
   
   Using these two functions, you can easily copy field definitions and data Rows from a
   TRtcDataSet object into any TDataSet descendant component (like TClientDataSet, for example).

2) "FishFactsClient" Project now has the "Server Address" and "Port" fields directly on the Form,
    so it can be used without modifications to connect to a "FishFactServer" runnig on a different PC.

3) "FishFactClient2" Project was added to the "Demos\DB_Access" folder.

   This new example Project is compatible with "FishFactServer" and "FishFactServer2" projects,
   but uses a "TClientDataSet" as in-memory dataset instead of a "TRtcMemDataSet", demonstrating
   the use of 3rd-party in-memory TDataSet descendant components on the Client side without making
   your Server-side code dependant on a particular TDataSet implementation, so you can use virtually
   any 3rd-party in-memory DataSet component on the Client side completely transparently.

   This is achieved by linking the in-memory TDataSet descendant (in this example a TClientDataSet)
   to a "TRtcMemDataSetMonitor" component, which is monitoring all important TDataSet events and
   has the same "OnDataChange" event and "ExtractChanges" method as the "TRtcMemDataSet" component.

4) "BDEDemoSever" Project was added to the "Demos\DB_Access" folder.

   This Project uses the BDE, implements a simple TSession (Database) object pool and creates 
   all Database Access Objects in code to make the Server safe for use in Multi-Threaded mode.

   It also introduces a simple way for allowing Clients to request only specific rows from a Table
   by sending a set of "filters" (in this example: Equal, Lower-Equal and Higher-Equal filter),
   which makes it suitable for writing Clients with Master/Detail relations.

---------------------------------------------------------
* Changes in v4.29
---------------------------------------------------------

1) TRtcDataSetChanges class and the TRtcDataSetAction type moved from the "rtcDB.pas" unit
   to the "rtcInfo.pas" unit, because they do NOT use the "DB" unit and could thus be used
   by Clients and Servers where real Database Access components are not required.

2) "FishFactServer2" Project was added to the "Demos\DB_Access" folder.

   This Project uses a single TQuery component from the BDE for Database access
   and demonstrates the use of SQL-capable Databases on the Server to process changes
   received by Clients which are using TRtcMemDataSet and TRtcDataSetMonitor components.

   "FishFactClient" Project can now also be used with the "FishFactServer2" Project.

---------------------------------------------------------
* Changes in v4.28
---------------------------------------------------------

1) "rtcParser.pas" unit updated to use file access functions from the "rtcInfo.pas" unit.

2) "rtcSDK_X.dpk" package was added, with a registration routine that will be adding only 
   cross-platform capable components to the component palette, so you won't get into a
   situaton where you have used a Windows-only component in a cross-platform project with XE2.

3) "FishFactServer" and "FishFactClient" Projects have been added under "Demos\DB_Access".
   These are very basic example Projects demonstrating the use of "rtcDB" components,
   allowing you to work directly with DB-aware components on the Client side.

---------------------------------------------------------
* Changes in v4.27
---------------------------------------------------------

1) "TRtcDataSetChanges" class introduced for easy access to data prepared by the 
   "ExtractChanges" method ("TRtcMemDataSet", "TRtcDataSetMonitor" and "TRtcDataSetRecorder").

2) Return data type of the "ExtractChanges" method changed to "TRtcValue" for easier handling.

3) "TRtcDataRow" class completed (some abstract methods were missing).

4) "TRtcDataSetCache" class renamed to "TRtcDataSetRecorder".

This update concludes all changes necessary for sending a DataSet from a Server to the Client,
displaying the DataSet inside DB-aware components on the Client, editing the DataSet on the 
Client and sending all Client side changes to the Server in form of insert/update/delete actions,
which can be used on the Server to inject any or all Client-side changes to the Database.

---------------------------------------------------------
* Changes in v4.26
---------------------------------------------------------

1) "TRtcMemDataSet" component extended with new properties and events for tracking
   changes made to the DataSet, writing a record of all modifications with enough
   information to apply the same changes to another DataSet or to undo local changes.

   Setting the new "TrackChanges" property to TRUE, all changes made to the DataSet
   will be monitored. Use the new "OnDataChange" event to get notified when changes
   were made. Then use the "ExtractChanges" method to get all changes as a TRtcArray.

2) "TRtcDataSetMonitor" class introduced to allow easy tracking of changes made
   to 3rd-party components based on the TDataSet class (custom in-memory datasets?).

   Setting the "Active" property to TRUE, all changes made to the assigned DataSet
   will be monitored and recorded. Use the "OnDataChange" event to get notified when 
   changes were made, then use the "ExtractChanges" method to get a TRtcArray instance
   containing all changes made to the DataSet since the last extraction.

3) "TRtcDataRow" class introduced as parent class of "TRtcDataSet".
   
   TRtcDataRow class makes it possible to pass a single complete ROW from a 
   TRtcDataSet to user functions and events, without giving the receiving functions
   and events access to methods for moving between ROWs, deleting ROWs or inserting 
   ROWs to the TRtcDataSet. Only methods and properties required for accessing and 
   modifying field info (name, size, type) and data inside a single ROW are made 
   available to the functions and events receiving the TRtcDataRow as parameter.

   By using the "TRtcDataRow.CreateFromDataSet(Source:TRtcDataSet)" constructor,
   it is also possible to give functions and events access to a select set of ROWs
   (each row through a separate TRtcDataRow instance) inside a single TRtcDataSet.

4) "DelphiDataSetToRTC" function updated to copy only Data Fields (FieldKind=fkData).

---------------------------------------------------------
* Changes in v4.25
---------------------------------------------------------

1) "rtc2DBTypes.pas" unit renamed to "rtcDB.pas" (Lib folder).

2) "DelphiDataSetToRTC" function moved to the "rtcDB.pas" unit
   and extended to work with all Delphi DB Types (including BLOBs).

3) "TRtcMemDataSet" component introduced and added to the "RTC Client" components tab ("rtcDB.pas" unit).

   "TRtcMemDataSet" is an in-memory TDataSet descendant (works with all DB-aware components)
   which uses a TRtcDataSet object for data storage, so you don't have to copy TRtcDataSet data
   to another in-memory DataSet if you only want to display its contents in a DB-aware component.

   Server-side example code to copy TDataSet data to a TRtcDataSet ("OnExecute" event):
   
     DelphiDataSetToRTC( MyDataSet, Result.NewRecord.NewDataSet('data') );

   Client-side example code to assign a TRtcDataSet to a TRtcMemDataSet ("OnReturn" event):
   
     if Result.checkType(rtc_Record) and 
        Result.asRecord.checkType('data',rtc_DataSet) then
       begin
       RtcMemDataSet1.asObject := Result.asRecord.asDataSet['data']; // assign RtcDataSet to RtcMemDataSet
       Result.asRecord.Extract('data'); // important after assigning to "RtcMemDataSet1.asObject" !!!
       RtcMemDataSet1.Active:=True; // activate RtcMemDataSet
       end;

---------------------------------------------------------
* Changes in v4.24
---------------------------------------------------------

1) Broadcasting capabilities added to RTC Linked Objects.
   
   With "Subscribe", Linked Objects can now subscribe to receive local broadcasts on specific "Channels".
   With "Unsubscribe", Linked Objects can unsubscribe from receiving broadcasts on specific "Channels".
   With "UnsubscribeAll", Linked Objects can unsubscribe from receiving ALL broadcasts on ANY "Channel".

   Using "Broadcast", Linked Objects can now broadcast calls to all *local* Linked Objects subscribed
   to a specific "Channel". The "Broadcast" method accepts "Channel" as a parameter, so that each
   broadcast can be sent to a different channel if needed. A "Channel" is simply a string.

   "OnBroadcast" event will be triggered on Linked Objects when a received broadcast was executed.

   IMPORTANT NOTE: 
     To make the Broadcasting feature as automated as possible, without forcing the use of a 2nd physical 
     connection on the Client and the Server, TRtcClientModule and TRtcServerModule have been extended to 
     automatically execute Broadcasts before and after each remote call and with every PING request received.
     But since the Server will NOT be able to communicate with a Client unless the Client is executing
     a remote function call, some broadcasts could take longer to reach their destination than others.

2) "Linked Objects" Quick Start examples extended to show the use of most Linked Objects features and more
   comments have been added to explain the source code (TloFileClient and TloFileServer) in more detail.

---------------------------------------------------------
* Changes in v4.23
---------------------------------------------------------

1) There was a problem with the "Linked Objects" feature because of which a
   temporary connection loss could result in all further "Linked Objects" communication 
   to stop, even after the connection was established again. This issue has been fixed.

2) AutoSessionsPing feature will now close the Session if a PING request was aborted
   due to connection problems (Session on the Server is either dead or out of sync).

---------------------------------------------------------
* Changes in v4.22
---------------------------------------------------------

1) Fixed problems found in the new "Linked Objects" feature:

  - Fixed a potential "stack overflow" error when using Linked Objects which are
    making a lot of circular calls to each other using a blocking transport.

  - Fixed a bug in the "TRtcLinkedModule" component where the remote linked object
    was being created before the local LinkedModule component was fully loaded,
    which resulted in early calls coming from the remote linked object to fail.

  - Fixed some errors in "Linked Objects" documentation.

  - TRtcLocalObjectManager now distinguishes a Client-side from a Server-side instance.

  - "RemoveManagedObjects" method added to TRtcClientModule.

  - "AutoSessionsPing" property would sometimes cause exceptions, because a request
    was posted while another request was being executed. This has now been fixed.
    PING request will now only be sent if there are no requests waiting in the queue.

  - Client-side Session and Object Manager were not cleared propperly after
    a request related to Linked Objects was aborted. This has now been fixed.
    Client will now automatically close a Session and free all Managed Objects
    in case a "Linked Objects" request was aborted (connection problems?)

  - Fixed a TRtcClientModule problem raising an exception on the Client after
    Linked Objects data was received from the Server without a list of errors.

  - There was a potential problem in the TRtcObjectLink class which could have
    resulted in the wrong Linked Object to be removed from the Object Manager
    if there was an exception in the TRtcObjectLink constructor (for example,
    by trying to create an Object with an OID which is already taken). 
    This has now been fixed and the new implementation will also send
    a message back to the original constructor to destroy its instance.

2) "isIdle" function added to TRtcDataClient, TRtcDataClientLink and TRtcDualDataClientLink
    components, which can be used at any time to check if the component is currently idle
    (no requests or responses pending).

3) New "Linked Objects" examples have been added to the "QuickStart" folder:

   - LinkedObjects\LinksLocal.dpr -> embedded Linked Objects example
   - LinkedObjects\LinksClient.dpr -> Linked Objects client demo
   - LinkedObjects\LinksServer.dpr -> Linked Objects server demo

   This is a simple demo showing how a "File Upload" Form on the Client 
   implemented using the "Linked Objects" functionality (TRtcLinkedModule component) 
   can talk to a Data Module on the Server to send file(s) to the Server.
