You can find information on updating the RTC SDK components in the "Readme.txt" file.

**********************************************************
*                                                        *
* RealThinClient SDK v3.47 (2010.Q1), January 21st 2010. *
*                                                        *
**********************************************************

This is the last RealThinClient SDK version usable with OLD encryption plugins. 

Starting with the next RTC SDK update (3.48 and later), you will only be able to use 
NEW encryption plugins for third-party SSL encryption support.

If you are wondering why the next RTC SDK version will NOT work with old encryption plugins, 
here are several reasons why you should stop using the old third-party encryption plugin, 
get the latest version of your encryption components and start using the NEW third-party 
encryption plugin for SSL support:

1. The old encryption plugins require every connection component to have a unique integer ID, 
which is passed to every single method called on the old plugin, which is used by the old plugin 
to search for the internal plugin object associated with the ID. Because this search is done for 
every single method call to the plugin and methods are called for every bit of data being sent and 
received, the old encryption plugins get increasingly slower with every connection in use.

This is NOT the case with the new RTC encryption plugins, which do NOT use an ID generated by the 
RTC SDK, but create an object of their own use inside the plugin and return a pointer to that object 
to the RTC SDK in the "AfterConnectEx" method, which is then passed back to all the other calls to 
the plugin made by the RTC SDK, so there is no more searching done inside the plugin, which means 
that there will be no performance drawbacks as the number of active connections grows.

2. The old encryption plugins ONLY work with the async WinSock API. Old encryption plugins 
do NOT work with the new blocking sockets implementation and will also NOT be working on 
any other platform than 32bit Windows.

The new encryption plugins do NOT have these limitations. The new encryption plugins can be 
used with async as well as blocking WinSock API and will be usable with the blocking BSD 
sockets on Linux and MacOSX (provided the encryption components are available for these platforms).

3. The old encryption plugins do NOT have a clean way to signal the RTC SDK that there was an 
error in encryption and that a connection should be closed. The old encryption plugin 
can only raise exceptions to do this.

The new encryption plugins have several states which they can set after each call to signal 
the RTC SDK what it should do next.

4. The old encryption plugins have no knowledge about where the connection is connected to, 
so they can not implement security measures to block access to insecure sites or block 
the use of invalid certificates.

The new encryption plugins are informed about the remote host and address, which can be used 
by the encryption plugin to decide if a certificate received from the other side can be trusted or not.


---------------------------------------------------------
* Build 347
---------------------------------------------------------

1) TRtcTimer class updated to improve handling of unexpected exceptions.

2) App_Client and App_Server demos updated to use the default thread pool size (64).

3) All DFM files (Forms and Data Modules) used in RTC SDK Demos updated to use the new 
   TEXT format instead of the old binary format to make them "Version Control friendly".

4) Removed "dproj" files from the "LibPlugins" folder which were causing problems in 
   some Delphi versions while trying to load the "dpk" (package) files.

5) Added "RTCWebForum", "WebForum_ISAPI", "RTCWebServer2" and "RTCWebPackManager" 
   projects to the "Delphi_Projects.bpg" project group in the "Demos" folder.

6) Lazarus App_Client and App_Server project files cleaned up (removed old file usage history).

7) Documentation for rtcRegister, rtcMemory, rtcTcpSrv, rtcTcpCli, rtcUdpSrv and rtcUdpCli units
   (none of which should be directly used in your projects) has been removed from the HELP file.

---------------------------------------------------------
* Build 346
---------------------------------------------------------

1) TRtcCryptPlugin interface and Socket connection providers extended to make it
   possible to use third-party encryption plugins with the blocking Sockets API.

   NOTE: You will be able to use old encryption plug-ins with the old Asynchronous
   WinSock API, but will need a NEW plugin implementation (using newly added features)
   if you want to use third-party encryption plugins (TRtcCryptPlugin) in blocking mode.
   You will also need a new plugin using this new interface to use third-party encryption
   components (like StreamSec Tools II) with the RTC SDK on non-Windows platforms (later).

2) StreamSec Tools II plugin updated to use the new TRtcCryptPlugin interface and
   a new "LibPlugins\rtcSSecTest.pas" unit was added to simplify plugin testing.

   ******* IMPORTANT INFO for existing RTC SDK + StreamSec Tools 2.x users *************
   * The new RTC CryptPlugin interface makes it possible for the plugin to check if    *
   * the certificate received was issued for the address we are connected to and is    *
   * going to GENERATE EXCEPTIONS if the appropriate Alert events are not implemented  *
   * on the StreamSec components. These exceptions were NOT raised in prior versions.  *
   * If you start getting exceptions while using the new plugin, chances are that      *
   * you did not implement all the required alert events on StreamSec components.      *
   * Please look at the "rtcSSecTest" unit to see which events need to be implemented. *
   * Any exception received from the plugin down by the RTC SDK components will        *
   * result in the connection to be closed, as if it was closed by peer (remote PC).   *
   *************************************************************************************

   ********************** !! IMPORTANT !! **********************************************
   * ===================================================================================
   * In order to add SSL encryption to your RTC Servers, we strongly recommend using
   * StreamSec Tools II version 2.1.9.240 or newer! StreamSec Tools II are high-quality,
   * high-performance SSL encryption components from http://www.streamsec.com/
   * ===================================================================================
   *************************************************************************************
 

3) TRtcDummyCryptPlugin component added (not registered on the component palette),
   using which it is possible to test how the RTC SDK is using encryption plugins
   without using a specific third-party encryption plugin implementation.

4) App_Client, App_Server, File_Client, File_Server and RTC_WebServer projects 
   from the "Demos" folder have been extended to work with SSL encryption by 
   using StreamSec Tools 2.1+ with the new CryptPlugin components if you 
   declare the "StreamSecII" compiler directive in Project Options.

   All the Demos are set up to work WITHOUT the third-party encryption 
   components by default, in which case the "CryptPlugin" checkbox will use a 
   dummy TRtcCryptPlugin implementation which does NOT add SSL encryption, but
   acts like a transparent tunnel (used for testing the TRtcCryptPlugin interface).

   NOTE: To compile the new extended demos and use SSL encryption with
   StreamSec Tools 2.x, in addition to having the latest commercial version 
   of StreamSec Tools 2.x compiled and installed, you will need to install the 
   StreamSec plugin for the RTC SDK (LibPlugins\rtcSDK_SSec.dpk) and declare the   
   "StreamSecII" compiler directive in project options or in the "rtcDeploy.inc" file.

5) Added two simple remote function Client and Server examples for C++Builder
   (to the "QuickStart\BCB_RemoteFunctions" folder).

6) Added more debug information to RTC SDK units. Debug information will be 
   written to a "DEBUG" log file if the "RTC_DEBUG" compiler directive is declared.
   All RTC SDK units initialization and finalization sections will now be logged.

   Also, to allow logging of memory deallocation in the rtcTrashcan unit,
   rtcInfo and rtcLog units are NOT using the rtcTrashcan unit anymore.
   Instead, the rtcTrashcan unit is using rtcLog and rtcInfo units to log
   possible errors during memory deallocation after the application closes.

7) Minor performance optimizations and a serie of stress-and-load test runs.

  This version has been extensively stress-and-load tested to make sure there are
  no errors or memory leaks in either the RTC SDK nor StreamSec Tools II (2.1.9.240).

  Tests have been performed by using 11 client PCs connecting to a Server PC with 
  two AppClient instances 'a 300 connections (600 connections per client PC) using 
  different settings to continuously send a combination of simple and complex remote 
  function calls to a Server PC running the AppServer demo which was using the new 
  blocking sockets implementation. A number of shorter tests (1 to 10 hours) have 
  been performed during the optimization and bug fixing process, plus one long and
  extensive test after all bugs have been fixed and all optimizations completed.
      

---------------------------------------------------------
* Build 345
---------------------------------------------------------

1) Updated the WinSock API layer to include support for IPv6 and IPv4,
   if the Operating System supports it. Because IPv6 is only available
   with newer WinSock versions, a newer WinSock DLL will now try to be
   loaded first instead of always loading the old DLL version. If the 
   new WinSock DLL isn't available, the older WinSock DLL will be used.

2) More internal changes for cross-platform support:

  * WinSock API access layers from "rtcWinSock" and "rtcSynLib" units 
    have been extracted and combined into a new universal "rtcWinSock" unit,
    which is now used for Synchronous and Asynchronous WinSock API calls.

  * Unix/Linux Socket access functions moved to the "rtcNixSock.pas" unit.

  * Socket implementations for all platforms moved to ".inc" files in the 
    "synsock" folder and included in the "rtcSynAPI.pas" unit.

  * "rtcSynLib.pas" unit is not used anymore and has been removed.

    This allows platform-specific Socket implementetions to be fully
    independent. In the prior version, all platform specific code
    was based on the BSD Sockets interfaces, while non-BSD 
    implemenations had to mimic BSD Sockets behavior by using wrapper
    functions. Now, entirely different implementations can be used
    for each platform, while most of the Socket access code is 
    being reused for all platforms (universal).

3) Fixed a few bugs related to the new "Blocking" property:

  * Changing the "Blocking" property on the "TRtcHttpClient" or 
    "TRtcHttpServer" components after the component has already been
    used had no effect in RTC SDK version 3.44, even if the connection
    was closed (listener stopped) before. This has now been fixed and 
    a change of the "Blocking" property will now correctly result in 
    releasing the current connection provider and creating a new 
    connection provider according to new property values.

  * LocalPort property value wasn't set after Listen on the 
    TRtcHttpServer component when Blocking=True. Fixed.

4) C++Builder had problems with a few "mem*" units. All "mem*" units 
   have now been updated to avoid problems with C++Builder and the
   refference to the old "rtcConnLimit.pas" unit was removed from
   the C++Builder installation package, so the RTC SDK can now
   again be installed without errors or warnings in C++Builder.

5) Fixed an issue with the WinInet and WinHTTP connection providers
   which resulted in a request to be sent twice when going through
   a proxy because username and password parameters weren't applied
   to the request object before reqest headers were sent out.


---------------------------------------------------------
* Build 344
---------------------------------------------------------

1) Implemented a NEW platform-independent (blocking) Socket connection 
   provider for use with the TRtcHttpClient and TRtcHttpServer components.

   This new connection provider was written from scratch, with the
   goal to use ONE universal code-base for ALL platforms and only
   map the low-level Socket API calls differently for each platform.

   There are now TWO independent connection provider implementations using 
   the WinSock API for Windows, so the old RTC_noWinSock compiler directive has 
   been split into two new compiler directives: RTC_noSynSock and RTC_noAsynSock.

   Declaring the "RTC_noAsynSock" compiler directive in your project(s),
   you will REMOVE support for the message-based connection provider 
   which is using the asynchronous WinSock API. Asynchronous WinSock API
   works ONLY on Windows and requires a message queue, which makes it a 
   bad candidate for console applications and other types of applications
   where a windows message queue is not present. If you are using the
   RTC SDK in such a scenario, declare the "RTC_noAsynSock" directive.

   On the other hand, by declaring the "RTC_noSynSock" compiler directive,
   you will REMOVE support for the new synchronous (blocking) connection
   provider which is using a platform-independent layer accessing the 
   synchronous (blocking) WinSock API on Windows, blocking FPC sockets API
   when compiled with FPC on non-Windows platforms like Linux and the 
   "Libc.so.6" library for using BSD sockets when compiled with Kylix.

   If neither "RTC_noSynSock" nor "RTC_noAsynSock" compiler directives are
   declared, synchronous *and* asynchronous connection providers will be 
   compiled into your Windows projects, in which case your connections properties
   will determine which connection provider will be used. Read below for more info.

2) A NEW "Blocking" property added to the TRtcHttpClient and TRtcHttpServer components, 
   allowing you to FORCE the use of a *blocking* (synchronous) connection provider.

   The "Blocking" property is FALSE by default to ensure backwards compatibility.

   When "Blocking" is TRUE, the exact same and fully platform-independent RTC SDK
   code will be used on ALL platforms. Only low-level API calls will be different.

   If RTC_noSynSock is NOT declared and "Blocking" is TRUE, which means that support 
   for using synchronous sockets API is included and you want to use it, the new 
   blocking Sockets API will be used on ALL platforms.

   If RTC_noSynSock is declared and "Blocking" is TRUE and you are compiling your
   project for Windows, WinHTTP API will be used if present, or WinInet API if not.
   Declaring RTC_noSynSock on non-Windows platforms will make the components unusable.

   When "Blocking" is FALSE on Non-Windows platforms, RTC Sockets implementation 
   will internally be using blocking sockets from within background threads to 
   transparently emulate non-blocking behavior and keep your applications behavior
   as close as possible to the default behavior on Windows using Async sockets.

3) Fixed a minor bug in the request repost functionality.


NOTE: TRtcTimer component is currently available ONLY for Windows.

since TRtcTimer component is used by the TRtcHttpClient and TRtcHttpServer components to
implement their "Timeout" properties and to trigger a delayed Reconnect when you set the 
"OnReconnect.Wait" property value (not 0), you will NOT be able to use the functionality
provided by these properties in projects compiled with FPC/Lazarus on Linux. But ... if
you do NOT use the "Timeout" properties and do NOT change the default "OnReconnect.Wait"
property (zero), you will already be able to use the RTC SDK on Linux with Lazarus/FPC.


---------------------------------------------------------
* Build 343
---------------------------------------------------------

1) Some minor fixes and more internal changes towards platform independence.

   Starting with this update, you will be able to use the latest RTC SDK
   release for writing Win32 applications with Delphi and Lazarus/FPC.
   You can NOT use the RTC SDK for writing non-Windows applications yet,
   because most of the code for direct access to the low-level OS APIs
   is currently ONLY implemented for Windows (WinSock, WinInet & WinHTTP).
   
   PS. According to my tests, the same application will work a lot faster
   when compiled with Delphi than when compiled with Lazarus/FPC, but that
   could also be a result of sub-optimal Lazarus/FPC compiler configuration.

2) ZLib 1.2.3 source files are now also included in the RTC SDK (Lib/zlib),
   together with a batch file to compile all ZLib files with C++ Builder.

   You do not need to recompile ZLib sources to use them with Delphi/Win32,
   because optimized OBJ files compiled with C++ Builder 2010 are included.

   NOTE: RTC compression is NOT supported by default for applications compiled
   with Lazarus/FPC, because provided OBJ files (optimized for Delphi) can NOT
   be consumed by the FPC compiler/linker. If you wish to use compression with
   the RTC SDK when working with Lazarus/FPC, you will have to recompile all
   ZLib C++ files from the "Lib/zlib" folder into the OBJ format which can be
   consumed by the FPC compiler, then add the {$DEFINE COMPRESS} line to the
   "Lib/rtcDefs.inc" file or add the COMPRESS directive to your Lazarus projects.
   
3) RTC_UseGarbageCollector compiler directive added (declared by default).

   If RTC_UseGarbageCollector is declared, objects and memory pointers
   which need to be freed at application shutdown will be freed only
   after all units finalization sections have completed their execution.

4) RTC_DEBUG compiler directive added (not declared by default).

   If you want to debug RTC SDK units loading and unloading,
   declare the RTC_DEBUG compiler directive.


---------------------------------------------------------
* Build 342
---------------------------------------------------------

1) Fixed a bug in the XML-RPC code for sending WideString values.

2) "MemTest" project under "Tools\UnitTests" split in two test
   runs (quick and full) and extended to show a lot more details.

3) AppClient, AppServer and RtcWebStressTool demo projects updated.

4) MSG_Client project from "Demos\RTC_Messenger" has been updated to
   have full Unicode support when compiled with Delphi 2009 and later.
   This means support for Unicode Usernames, Passwords and Text.

   All dependencies on third-party components and unsupported units
   have also been removed, so that MSG_Client and MSG_Server can now
   be compiled without any modifications with Delphi 6 - 2010.

5) Configuration on all Demo projects updated to use default stack
   sizes instead of minimalistic values which are causing WinSock
   to not work at all (server not listening, client not connecting).

   All Demos will now compile and work propperly with Delphi 6 - 2010.

6) More internal low-level design and implementation changes
   to make the RTC SDK code even more platform-independent.

   None of the classes and units changed in this internal update are
   normally used by RTC SDK component users, which means that this update
   should NOT affect existing projects which are using the RTC SDK.

   If you are using any of these units and classes directly in your
   projects, please consider changing your code to work without it
   to keep it more platform-independent.

   Here is a short list of applied changes:

  * Unit rtcSockBase added, with a new TRtcSocketBase class and a
    number of other generic Socket classes (not platform specific).

  * Unit rtcWinSock now provides a single TWinSocket class, which is
    based on the new TRtcSocketBase class to make it interchangeable.

  * Class TRtcWSockClientProvider renamed to TRtcSocketClientProvider
    and all dependencies on the rtcWinSock unit and TWinSocket class
    removed, so it can be used with any class based on TRtcSocketBase.

  * Class TRtcWSockServerProvider renamed to TRtcSocketServerProvider
    and all dependencies on the rtcWinSock unit and TWinSocket class
    removed, so it can be used with any class based on TRtcSocketBase.

  * Unit rtcWSockClientProv renamed to rtcSocketClientProv.

  * Unit rtcWSockServerProv renamed to rtcSocketServerProv.

  * Unit rtcSockets added for setting up the low-level Sockets API
    so that TRtcSocketClientProvider and TRtcSocketServerProvider
    classes only need to use its "DefaultSocketClass" global
    variable and do not require any platform-specific code.

  * Unit rtcConnLimit deprecated and removed from the "Lib" folder, as well
    as the "Processing" method, which has been using the rtcConnLimit unit.

  * "Run" method on the TRtcJob class changed from procedure to function
    which has to return TRUE if the object (TRtcJob instance) should be freed.

    Now, instead of using Free from inside the Run method to release the
    instance, it is safer to return "TRUE" as a result of the "Run" method
    and let the caller free the object (provided you want it freed).

    Also, because of this addition, any code directly calling the "Run"
    method of any TRtcJob object has to free the object if "Run" has
    returned TRUE as a result. Not doing so will result in memory leaks.


---------------------------------------------------------
* Build 341
---------------------------------------------------------

1) Some internal units and classes have been re-organized to make the
   RTC SDK more platform-independent. These changes do NOT affect the
   way any higher-level RTC SDK components are being used, so all the
   projects using the RTC SDK will continue working as before:
 
  a) Classes in the "rtcSyncObjs" unit changed to extend classes from the
     "SyncObjs" unit shipped with Delphi instead of making direct API calls.

  b) "GetTickTime" function, a platform-independent version of the Windows
     "GetTickCount" API function, has been added to the "rtcInfo.pas" unit.
 
  c) Low-level TCP/IP connection providers have been split into the
     basic Socket provider wrappers and specific Socket implementations
     to allow maximum code re-use when more low-level TCP/IP providers
     have to be added with completely different platform-specific code.

  d) Units with Platform-independent code for HTTP connection providers renamed:
      rtcWSockHttpCliProv => rtcSocketHttpCliProv
      rtcWSockHttpSrvProv => rtcSocketHttpSrvProv

  e) Classes with platform-independent HTTP connection providers renamed:
      TRtcWSockHttpClientProvider => TRtcSocketHttpClientProvider
      TRtcWSockHttpServerProvider => TRtcSocketHttpServerProvider

  f) WinSock API implementation unit renamed:
      WSocket_rtc => rtcWinSock

2) TRtcHttpClient component updated to pick alternative connection
   providers if the one chosen by the component user is not available.

3) Updated the TRtcHttpClient and TRtcHttpServer components to make it
   possible to *remove* support for the WinInet, WinHTTP and/or WinSock API
   from a project using the RTC SDK. This is useful if you need to keep you
   exe file size as small as possible and know that you will only be using
   specific low-level APIs all over your code (for example, only WinInet).

   Please look at the "rtcDefs.inc" file in the "Lib" folder for a
   list of all supported compiler directives and their explanations.

4) "UnitTesting" folder with a "MemTest" project added under "Tools",
   providing ready-to-use automated unit testing for these classes:

     tObjList
     tBinList
     tStrList
     tStrIntList
     tStrObjList
     tStringIntList
     tStringObjList
     tBinTree

   NOTE: These are "correctness" tests and NOT performance tests!
   To ensure that each class is working correctly in all cases,
   a number of tests are running after every single operation.

   Because all these classes implement various balanced binary search
   lists/trees, a complete set of checks using all the available search
   functions is executed on the whole structure to check that every
   element in the list/tree is where it should be and will be found
   using the appropriate search methods. This comprehensive test method
   means that any inconsistency with expected results will result in the
   test being terminated with an exception and a brief error message.

   But, this also means that the test duration is NOT linear to the maximum
   number of elements used in testing. Even though all the tests can complete
   in a few seconds when run with a few hudred elements per list/tree,
   it will most likely take several MINUTES or even an HOUR to complete
   the test with a few thousand elements, and several HOURS or even DAYS
   to complete the test with tens of thousands of elements and more. 

   Because all the tests are running as console applications, they can
   be terminated at any time by pressing the <Ctrl>+<C> key combination.

5) String<->Date conversion routines in the "rtcInfo.pas" unit which
   are used when sending and receiving Date and Time values with remote 
   functions were updated to recognize a date with zero values for year,
   month and day as valid NULL dates instead of raising EConvertError.

6) Some minor modifications to a few examples in the QuickStart folder.

---------------------------------------------------------
* Build 340
---------------------------------------------------------

1) C++ Builder package file (rtcSDK_C.bpk) has been updated to compile and install in C++ Builder 6 and later.

---------------------------------------------------------
* Build 339
---------------------------------------------------------

1) To avoid code duplication, all functions from "mem" units have been extracted to a separate "sort" folder (under "Lib").

2) To avoid deletion of required OBJ files during folder clean-up, all OBJ files moved to a separate "zlib" folder (under "Lib").

3) TRtcClientModule and TRtcServerModule updated to automatically keep Session IDs synchronized between each Client and the Server,
   even if Automatic Session handling is NOT enabled and you are opening and closing Sessions manually in your remote function code.

   This addition makes it easy to use manual session handling with RTC remote functions,
   without the need to send session IDs manually back and forth, making it easy to implement
   you own session opening and closing mechanisms without being forced to use automatic sessions.

   NOTE: When Automatic Sessions are enabled, the code still works as before.
   The only difference is that you do not have to manually send the Session ID
   to the Client if you open a session manually and you do not need send the Session ID
   back to the Server manually when using your own (manual) session opening and closing code.

4) QuickStart\RemoteFunctions example extended to demonstrate how the new Session ID synchronization
   works when using manual session opening and closing without using AutoSessions on Client or Server.


---------------------------------------------------------
* Build 338
---------------------------------------------------------

1) "LastResult" property added to the TRtcClientModule component:

   After the last "Execute" call, if you have used the default value (TRUE) for the "AutoFreeResult" parameter
   ("Execute" or "Execute(True)") to signal the component that you do NOT want to keep the result object to yourself
   and that you want the result object to be freed automatically by the component before the next "Execute" call,
   you can use the "LastResult" property to access the last object returned from the "Execute" method.

   Please note that the "LastResult" property will point to the result returned from the LAST "Execute" call.
   "LastResult" will return NIL if there was an error during the last Execute call (the call was not finished)
   or if you have last used Execute(FALSE) -> using "AutoFreeResult=FALSE" in your Execute call parameters. }


2) "Param" property added to the TRtcClientModule component:

   After using "Prepare" or "Data.newFunction" to create a new Function call object,
   you can use the "Param" property to prepare all your function call parameters.

   Using "Param" is identical to using "Data.asFunction"


3) Default value for "AutoFreeResult" parameter in the "Execute" method on TRtcClientModule
   component changed to TRUE, since that makes the code easier to use (no need to free the result).

   And here is the updated explanation for "Execute" method usage ...

   There are two ways one can use "Execute":
     1) The easy way is to use "Execute" or "Execute(TRUE)" (meaning that AutoFreeResult=TRUE),
        in which case the Result object you receive will be automatically destroyed the next time
        you use the "Execute" method, or when the TRtcClientModule component is being destroyed.
     2) The advanced way is to use "Execute(FALSE)", in which case you will have to FREE the
        result object received from "Execute(FALSE)" manually, once you are finished using it.

   Using the "Execute" method is easier than using the "Call" method because:
     (A) You will have access to the result data immediately after the "Execute" line,
         in the same code segment where you have "executed" your remote function call.
     (B) You can either keep the result object for as long as you want and free it manually
         when using "Execute(FALSE)", or ... you can let the TRtcClientModule component free
         the result object automatically for you by using "Execute" or "Execute(TRUE)".

   Also take a look at the "LastResult" property, which is available to you if you call Execute with
   its default value for the AutoFreeResult parameter (TRUE) and gives you direct access to the result
   object received from the Execute method without having to use local variables or the "with" statement.

   Here are three usage examples, all of which are basically
   doing the same thing, but each using a different syntax.
   You can combine them any way you want:

   ** EXAMPLE 1 **

      with MyClientModule do
        begin
        Prepare('myfunctionname');
        Param.asString['par1']:='Hi';
        Param.asInteger['par2']:=12345;
        Execute;
        // use the "LastResult" property to access the result data
        end;

   ** EXAMPLE 2 **

      with MyClientModule do
        begin
        with Prepare('myfunctionname') do
          begin
          asString['par1']:='Hi';
          asInteger['par2']:=12345;
          end;
        with Execute do // result object will be Freed automatically
          begin
          // ... access the result data here ...
          end;
        end;

   ** EXAMPLE 3 **

      with MyClientModule do
        begin
        Data.Clear;
        with Data.newFunction('myfunctionname') do
          begin
          asString['par1']:='Hi';
          asInteger['par2']:=12345;
          end;
        myRes:=Execute(False); // you will need to Free "myRes"
        try
          .. use myRes ...
        finally
          myRes.Free;
          end;
        end;


---------------------------------------------------------
* Build 337
---------------------------------------------------------

1) WaitForCompletion, WaitForCompletionEx and DoWaitForCompletion methods extended
   with an additional optional parameter "AllowMessageProcessing" (default=True).

   When used with its default value (FALSE), WaitForCompletion will now be working
   exactly as it has been working before the latest additions, processing messages
   while waiting for a result. This ensures full backwards compatibility with
   applications using the old WaitForCompletion implementation while allowing
   everyone to make full use of the new extended functionality in multithreaded mode.

2) "Execute" method extended with optional "Timeout" and "AllowMessageProcessing"
   parameters, allowing you to specify the maximum waiting timeout and specify if 
   you want to allow basic message processing (message loop) while waiting.

   Timeout=0 (infinite) and AllowMessageProcessing=True (use message loop) by default.

---------------------------------------------------------
* Build 336
---------------------------------------------------------

1) Component icons updated

2) "DoWaitForCompletion" and "WaitForCompletionEx" methods added to all 
   components which have already had the "WaitForCompletion" method.

   "DoWaitForCompletion" method will return a bit more information:
    - wait_Error on connection error
    - wait_Quit when application is about to quit
    - wait_timeout when using a timeout parameter and request not completed on time
    - wait_Msg when user message was triggered while waiting
    - wait_OK when everything went as expected (request completed)
   
   "WaitForCompletionEx" will raise an exception in case of a failure, or
   return normally (no exception) if everything was OK (request completed).

3) Implementation of the "WaitForCompletion" (now also "DoWaitForCompletion" and 
   "WaitForCompletionEx") method has been improved to eliminate CPU usage and
   return immediately upon request completion if you are using a MultiThreaded 
   Client and the method was called with UserInteractionAllowed = FALSE (default).

4) Added "RTC_WAITFORCOMPLETION_SLEEP" global variable to the "rtcDataCli" unit,
   allowing you to customize how long you want WaitForCompletion to sleep (ms)
   between each check inside a message loop while waiting for a response from 
   the Server when using Client connections in single-threaded mode and calling 
   WaitForCompletion with the "UserInteractionAllowed" parameter set to TRUE.

5) "Prepare" method added to the TRtcClientModule component to make preparation
   of new remote function objects as easy as posssible and also eliminate the need 
   to manually clean-up the "Data" property if an exception is raised during preparation.

6) "Execute" method added to the TRtcClientModule component to simplify the use of the RTC SDK
    for making synchronized (blocked) remote function calls where you want to have access to a
    result object directly from where you have prepared and executed your remote function call.

   If you want to send a remote function call to the Server and wait for the result without
   using a separate TRtcResult component and without writing the OnResult and OnAbort events,
   you can prepare a synchronized (blocking) call by using the "Prepare" method and then
   (once prepared) execute the remote call and get a result by using the "Execute" method.

   In case of a communication error during the remote call, the "Execute" function will
   raise an exception with the appropriate error text. If everything goes well (no exeception),
   you will get your result directly from the "Execute" method in form of the TRtcValue object.

   WARNING: Because of its blocking implementation, "Execute" method can NOT be used from events triggered
   by the RTC SDK (for example, from the OnResult or OnAbort events triggered by a remote call issued by
   using the "Call" method) and ... the "Execute" method can ONLY be used from one thread at a time.

   Here are three usage examples:

   ** "EXECUTE" EXAMPLE 1 **

   with MyClientModule do
     begin
     with Prepare('myfunctionname') do
       begin
       asString['par1']:='Hi';
       asInteger['par2']:=12345;
       end;
     myRes:=Execute; // you will need to Free "myRes"
     try
       .. use myRes ...
     finally
       myRes.Free;
       end;
     end;

   ** "EXECUTE" EXAMPLE 2 **

   with MyClientModule do
     begin
     with Prepare('myfunctionname') do
       begin
       asString['par1']:='Hi';
       asInteger['par2']:=12345;
       end;
     with Execute(TRUE) do // result object will be Freed automatically
       begin
       // ... access the result data ...
       // do NOT Free the result object!
       end;
     end;

   ** "EXECUTE" EXAMPLE 3 **

   with MyClientModule do
     begin
     with Prepare('myfunctionname') do
       begin
       asString['par1']:='Hi';
       asInteger['par2']:=12345;
       end;
     myRes:=Execute(TRUE); // result object will be Freed automatically
     ... use "myRes" ...
     // do NOT free "myRes"! It will be Freed automatically
     // the next time you use the "Execute" method.
     end;

7) "QuickStart/RemoteFunctions" Client-side example updated to use the
    new "Prepare" and "Execute" methods instead of "Data" and "Call"
    to demonstrate two simple ways of using these new methods and show
    how remote function calls can now be made without the need to use
    TRtcResult components or write separate events for handling results.

    And here is the complete code for the "EditKeyPress" event
    without using the RtcResult component and without extra events ...

    if Key=#13 then
      begin
      Edit1.SelectAll;
      with RtcClientModule1 do
        begin
        with Prepare('hello') do
          asString['name']:=Edit1.Text;
        with Execute(True) do
          // here, we have the result data ...
          Memo1.Lines.Add(asString);
        end;
      end;

---------------------------------------------------------
* Build 335
---------------------------------------------------------

Updated the implementation of the "rtcDBTypes" unit using "case" instead
of a static array, which will compile with all current and later Delphi 
versions and will throw an exception in case you use a Delphi field type
in a TDataSet descendant which is not natively supported by the RTC SDK.

---------------------------------------------------------
* Build 334
---------------------------------------------------------

The RealThinClient SDK has grown too big, with too many things which
were added but not actively supported over the last five years.

To correct this and make the RealThinClient SDK into a real light-weight 
component set for writing stable HTTP(S) Clients, Servers and ISAPI extensions
with all the functionality required for these tasks but nothing more,
the RealThinClient SDK package has now been cleaned-up to include only
components and demos which will continue being actively updated and supported.

None of the source code, components or demos which have been removed
have ever been fully supported nor listed on the "About RTC SDK" web page.
Everything you see on the official RealThinClient SDK web page is still 
included and will continue being fully supported and maintained/developed:

> http://www.realthinclient.com/about.htm

And here is the list of things which have now been removed or changed:

1) Since all support for Lazarus/FPC has been discontinued,
   all Lazarus/FPC source code, components and Demos have been removed.

2) Because there is no support for using Low-level TCP/IP and UDP components,
   Low-Level TCP/IP and UDP components will NOT be registered on the components
   palette and all Low-Level TCP/IP and UDP Demos have now been removed.

3) While the last RTC WAF implementation included with the RTC SDK was only
   an experimental BETA and there is no official support for using this code,
   all "RTC WAF" source code, components and demos have now been removed.

4) Unsupported third-party plugins and demos have been removed.

5) "Readme.txt" file has been updated to reflect all changes.


---------------------------------------------------------
* Build 333
---------------------------------------------------------

License Agreement has been updated to reflect the fact
that this is a COMMERCIAL version of the RealThinClient SDK
and may NOT be freely redistributed in source code form.

Here is the complete License Agreement Text:

RealThinClient Web Application Components
http://www.realthinclient.com

Copyright (c) 2004-2009 RealThinClient components
All rights reserved.

By using the RealThinClient SDK (aka "RTC SDK"),
you are accepting these licensing terms ...

You have the right to use the files contained in this package to build your own 
products and sell, copy, give away or distribute your products in executable form, 
without paying any royalties. You also have the right to build plug-ins and/or 
add-ons for RTC SDK and sell, copy, give away or distribute your plug-ins and add-ons 
in any form, without paying any royalties. 

You do NOT have the right to include RTC SDK files with your product, plug-in and/or 
add-on. You may NOT distribute, copy, give away or sell any files or even parts of 
files from the RTC SDK package. This limitation also applies to all modified and/or 
compiled versions of those files, including but not limited to source code, compiled 
units, object files and dynamic link libraries.

You may not propagate or modify a covered work except as expressly provided under this License.
Any attempt otherwise to propagate or modify it is void, and will automatically terminate 
your rights under this License. This License and the rights granted hereunder will terminate 
automatically if You fail to comply with terms herein and fail to cure such breach within 7 days 
of becoming aware of the breach. Provisions which, by their nature, must remain 
in effect beyond the termination of this License shall survive.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR 
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
